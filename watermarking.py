import numpy as np
import pywt


# Splits a given array in two arrays based on the index's parity. An array will contain all elements with even indeces, while the other will contain the elements with odd indeces
# Used for spliting a segment in two groups for watermark embedding and detection.
#
# arr               -- input array to be split
#
# RETURN            -- two arrays, one of even elements of even indeces, and one of elements of odd indeces
def split_by_parity(arr):
    even_indices = [arr[i] for i in range(len(arr)) if i % 2 == 0]
    odd_indices = [arr[i] for i in range(len(arr)) if i % 2 != 0]
    return even_indices, odd_indices

# Combines two arrays into a single array by alternatively selecting elements from the given arrays. It will select one element from the first array then one from the second one.
# This assumes that the two arrays have the same length, or the first one is one element larger than the second.
#
# arr1              -- first array
# arr2              -- second array
#
# RETURN            -- one array, the result of combining the two arrays
def reconstruct(arr1, arr2):
    res = []
    for i in np.arange(0, len(arr1) - 1):
        res.append(arr1[i])
        res.append(arr2[i])
    res.append(arr1[len(arr1) - 1])
    if (len(arr2) == len(arr1)):
        res.append(arr2[len(arr1) - 1])
    return res

def split_arr(arr):
    m = int(len(arr)/2)
    l = arr[:m]
    r = arr[m: ]
    return l, r

def reconstruct_alt(l, r):
    return np.concatenate((l, r))

############################################################################             WATERMARKING            #############################################################################


# Embedd watermark generated by a key into a given dataset
#
# x                     -- the original dataset to be watermarked
# key_watermark         -- the key by which the watermark bits will be pseudo randomly generated
# key_splitSelection    -- the key by which the segment for watermark embedding will be selected
# selectedSplits        -- the number of segments that will be selected for watermarking
# nrOfSplits            -- the total number of segments the data will be split into. This should not be larger than 10% of the data.
#                           For number larger than that, the data will be altered to drastically 
# DWT_MAX_LEVEL         -- the max level of the DWT transform, How many times the DWT transform is applyed
#
# RETURN                -- an array of numbers == the watermarked data
def embedWatermark(x, key_watermark, key_splitSelection, selectedSplits, nrOfSplits, DWT_level):

    splits = np.array_split(x, nrOfSplits)
    np.random.seed(key_watermark)
    bits = np.random.choice([0, 1], size = selectedSplits)
    np.random.seed(key_splitSelection)
    mark = np.random.choice(range(nrOfSplits), size = selectedSplits, replace=False)

    # print (bits)
    # print (mark)
    total_change = 0

    for i in np.arange(mark.size):
        s1, s2 = split_arr(splits[mark[i]])
        coef_s1 = pywt.wavedec(s1, 'db1', level=DWT_level)
        coef_s2 = pywt.wavedec(s2, 'db1', level=DWT_level)
        cA_1 = coef_s1[0]
        cA_2 = coef_s2[0]
        mean_s1 = np.mean(cA_1**2)
        mean_s2 = np.mean(cA_2**2)
        dif = np.abs(mean_s1 - mean_s2)
        # print(dif)

        changed = False

        wm_cA_1 = cA_1
        wm_cA_2 = cA_2
        if (mean_s1 < mean_s2 and bits[i]):
            changed = True
            bar_mean_s1 = mean_s1 + dif * 0.5
            bar_mean_s2 = mean_s2 - dif * 0.5
            wm_cA_1 = cA_1 * bar_mean_s1 / mean_s1
            wm_cA_2 = cA_2 * bar_mean_s2 / mean_s2
            total_change += 1
            # print('A')
            # print(np.mean(wm_cA_1))
            # print(np.mean(wm_cA_2))
            # print(mark[i])
            
        elif (mean_s1 > mean_s2 and bits[i] == 0):
            changed = True
            bar_mean_s1 = mean_s1 - dif * 0.5
            bar_mean_s2 = mean_s2 + dif * 0.5
            wm_cA_1 = cA_1 * bar_mean_s1 / mean_s1
            wm_cA_2 = cA_2 * bar_mean_s2 / mean_s2
            total_change += 1
            # print('B')
            # print(np.mean(wm_cA_1))
            # print(np.mean(wm_cA_2))
            # print(wm_cA_1)
            # print(wm_cA_2)
            # print(mark[i])

        coef_s1[0] = wm_cA_1
        coef_s2[0] = wm_cA_2
        wm_s1 = pywt.waverec(coef_s1, 'db1')
        wm_s2 = pywt.waverec(coef_s2, 'db1')
        
        # If the lenght is odd, the decomp will generate an even number of composing factors, that after IDWT will have an extra number at the end. 
        # This nuber is equal to the one before it.
        # This is caused due to the last detail element being 0. In this case, last element can be removed to retrieve original set
        #
        if len(s1) % 2:
            wm_s1 = wm_s1[: -1]
        if len(s2) % 2:
            wm_s2 = wm_s2[: -1]

        
        
        if changed:
            # print(mean_s1, mean_s2, mean_s1-mean_s2, bits[i], changed,  np.mean(wm_cA_1**2) - np.mean(wm_cA_2**2))
            splits[mark[i]] = reconstruct_alt(wm_s1, wm_s2)
    
    print(total_change)
    return np.concatenate(splits)

# Extracts watermark from input data
#
# x                     -- input data to check for watermark
# key_splitSelection    -- key by which indexes will be pseudo randomly generated
# selectedSplits        -- nr of segments selected for watermark checking. Each segment contains one bit of information
# nrOfSplits            -- total number of segments the data will be split into
# DWT_MAX_LEVEL         -- the max level of the DWT transform, How many times the DWT transform is applyed
#
# RETURN                -- an array of bits(0/1) == the watermak that can be extracted from the data
def extractWatermark(x, key_splitSelection, selectedSplits, nrOfSplits, DWT_level):

    splits = np.array_split(x, nrOfSplits)
    np.random.seed(key_splitSelection)
    mark = np.random.choice(range(nrOfSplits), size = selectedSplits, replace=False)

    # print(mark)

    res = []
    for i in np.arange(mark.size):
        s1, s2 = split_arr(splits[mark[i]])
        coef_s1 = pywt.wavedec(s1, 'db1', level=DWT_level)
        coef_s2 = pywt.wavedec(s2, 'db1', level=DWT_level)
        cA_1 = coef_s1[0]
        cA_2 = coef_s2[0]
        mean_s1 = np.mean(cA_1**2)
        mean_s2 = np.mean(cA_2**2)
        dif = mean_s1 - mean_s2
        # print(mark[i], dif)
        if dif > 0:
            res.append(1)
        else:
            res.append(0)

    return res


# Verifies if the generated watermark is equal to the watermark extracted from the data
#
# key_watermark         -- the key to generate the pseudo random bits of the watermark
# watermarkLength       -- the desired lenght of the watermark
# extractedWatermark    -- the watermark previously extracted from the dataset
#
# RETURN                -- True if generated watermark is equal to the given watermark, or False otherwise
def verifyWatermark(key_watermark, watermarkLength, extractedWatermark):
    np.random.seed(key_watermark)
    bits = np.random.choice([0, 1], size = watermarkLength)
    # print(bits)
    # print(extractedWatermark)
    return (np.array(bits) == np.array(extractedWatermark)).all()
